# Tutorial

We will introduce some basic concepts in the HazardFlow HDL programming model and use HazardFlow HDL to describe an [FIR (finite impulse response) filter](https://en.wikipedia.org/wiki/Finite_impulse_response) and a masked merge combinator.

## Hazard Interface and Combinator

HazardFlow HDL's implementation is based on two important concepts: [hazard interface](./interface.md) and [combinator](./module.md). 
We will give a brief explanation here about the interface and combinator for you to understand how to use them to implement the FIR filter and fair multiplexer.
For more details please refer to the [Language Reference](./reference.md) section.

### Hazard Interface

In HazardFlow HDL, we define the hazard as a protocol including the payload, resolver, and transfer condition.
We model the hazard interface as a structure containing its forward signal, backward signal, and the transfer condition specified by its hazard.
We define the hazard protocol as `H`, its payload and resolver as `H::P` and `H::R` respectively.

<p align="center">
  <img src="../figure/interface.drawio.svg" />
</p>

**Forward signal:**
* The forward signal is the payload of the interface. 
* It is the data will be sent from the sender to the receiver.
* We define it as an `Opt<H::P>` type. When it is `Some(p)`, the sender is sending a valid payload, else it is sending an invalid payload.

**Backward signal:**
* The backward signal is the resolver of the interface.
* It represents the hazard generated by the later stage from the circuits and it will be sent from the receiver to the sender.
* We define the resolver signal as `H::R`

**Transfer condition:**
* Indicates whether the receiver is ready to receive the payload.
* We define the transfer condition as `fn ready(p: Self::P, r: Self::R) -> bool;` where the `p` is the payload and `r` is the resolver.
* When the forward signal is `Some(p)`, which means the forward signal is valid, **and** the transfer condition returns `true`, which means the receiver is ready to receive the valid payload, then the transfer happens.
* When the forward signal is `None`, which means the forward signal is invalid, **or** the transfer condition returns `false`, which means the receiver is not ready to receive the valid payload, then the transfer is not happening.

### Combinator

Combinator is the idiomatic mechanism of chaining two interfaces together in HazardFlow HDL.

<p align="center">
  <img src="../figure/combinator.drawio.svg" />
</p>

We define a combinator as a function `fsm` within each hazard interface in the HazardFlow HDL and it will be called each clock cycle.
It will take the initial state of the combinator and an anonymous function as input return the new interface and chain these two interfaces together as shown in the above figure.
The anonymous function specifies the logic of calculating the payload will be sent to the next combinator, the resolver will be sent to the previous combinator, and the next state of the current combinator.

We define the hazard type for the ingress interface as `H` and `EH` for the egress interface.

**Ingress payload:**
* This is the forward signal of the ingress interface.
* It is considered as a given input and it will be taken as an argument for the anonymous function.

**Egress resolver:**
* This is the backward signal of the egress interface.
* It is considered as a given input and it will be taken as an argument for the anonymous function.

**Egress payload:**
* This is the forward signal of the egress interface.
* This signal will be calculated within the anonymous function.
* This signal will be sent as the payload to the next combinator.

**Ingress resolver:**
* This is the backward signal of the ingress interface.
* This signal will be calculated within the anonymous function.
* This signal will be sent as the resolver to the previous combinator.

**State:**
* We interpret this as the register status within the combinator.
* The current state of the combinator will be taken as an argument for the anonymous function.
* The next state of the combinator will be calculated within the anonymous function.

**The anonymous function:**
* This is the function we used to update the payload to the next combinator, resolver for the previous combinator, and the next state of the current combinator.
* We define the signature of the `fsm` as:

  ```rust,noplayground
  pub unsafe fn fsm<S: Copy, const ED: Dep, EH: Hazard>(
      self, init_state: S, f: impl Fn(HOption<H::P>, EH::R, S) -> (HOption<EH::P>, H::R, S),
  ) -> I<EH, ED>
  ```

* We can ignore the `Dep` and `unsafe` for now.

HazardFlow HDL defines some primitive combinators and hazard interfaces for developers.
The users can use these primitive combinators and hazard interfaces to construct their own combinational logic conveniently.
